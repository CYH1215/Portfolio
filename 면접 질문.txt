스택 - FILO
큐 - FIFO

*벡터와 리스트

리스트는 연속된 메모리 공간을 차지한다.
즉 공간 활용 능력이 뛰어나다.

하여 데이터의 크기가 수시로 변할 때에는 벡터보단 리스트가 좋다.

반면 벡터는 접근 속도가 빠르다.

하여 데이터의 크기가 클 경우, 미리 만들어 두어야 하는 경우 벡터를 쓰는 것이 좋다.

벡터 같은 경우는 인벤토리같은 고정형 리스트로 쓰고, 리스트의 경우 총알같이 수시로 추가되는 오브젝트가 좋다.

데이터의 삭제가 빈번할 경우 벡터는 쓰지 않는것이 좋다.

//테이블(딕셔너리)(C++ 에선 UnOrderedMap).

Key와 Value로 나눠진 값을 가진 데이터 형식.

배열처럼 보이지만 배열이 아니다. A[Key] 이런 식으로 접근한다.

Hash 테이블 (Hash맵)을 많이 쓴다.

속도가 엄청 빠르기 때문.

색인 이라고도 부른다.


*스레드와 프로세스

프로세스 - 실행중인 프로그램
프로그램이 실행되면 4가지 메모리 영역이 할당된다.(Code, Data, Stack, Heap)
Code - 함수가 저장되는 공간. 프로그래머가 작성하는 함수들이 저장된다.
Data - 전역 변수나 스태틱.(상수나 const데이터들) 이 공간은 프로그램이 실행되면 생성되고, 프로그램이 종료되어야 사라진다. 또한 이 공간은 프로그래머가 수정 할 수 없다.
Stack - 지역 변수(로컬 변수)가 저장되는 공간. 
Heap - 참조형 변수들의 본체가 생성되는 공간. 이 공간은 프로그래머가 관리해야한다.

스레드 - 프로세스 안에서 만들어내는 것.
모든 프로세스는 최소한 1개 이상의 스레드를 가진다.
스레드는 Stack 메모리 영역만 가지게 된다.
Coroutine을 생각하면 된다.(Coroutine은 스레드가 아니지만 흉내를 낸 것이다.)
Coroutine 내에서 선언한 변수들은 루프가 끝나면 사라지게 된다.

2개의 스레드가 서로 같은 값을 수정하려고 하면, 모순이 일어나게 된다. 그렇기 때문에 멀티 스레드를 사용할 경우 먼저 접근한 스레드가 해당 메모리에 Lock을 걸어버려서 다른 스레드가
접근을 할 수 없게 만든 뒤 수정이 끝나고 UnLock을 하여 풀어주게 된다.
스레드가 접근을 시도할 때 Lock 상태라면 대기 한 뒤 UnLock이 되면 그 때 접근한다.

2개의 스레드가 서로를 접근하려고 하면 서로의 메모리를 Lock 걸어버린 채 상대 메모리의 UnLock을 기다리기에 무한 대기 현상이 발생한다. 이를 DeadLock이라 한다.

스레드의 개수가 늘어난다고 코스트가 엄청 늘어나고 그러진 않는다. 기본적으로 사용되는 메모리는 1개이기 때문.


* C++, C#의 차이점 and C#이 더 느린 이유

메모리를 직접적으로 관리할 수 있는 게 C++, 없는게 C#

C#은 기본적으로 항상 컴파일을 하고 있고, C++은 내가 원할 때에 컴파일을 할 수 있다.

C++은 include가 있어서 사용하고자 하는 것을 골라 사용할 수 있는데(최적화 가능), C#은 모든 클래스가 이미 Include된 상태라고 볼 수 있다(최적화 불가능).
C++은 메모리 관리나 라이브러리 관리쪽으로 최적화를 할 수 있는 반면, C#은 그렇지 않다.
// 사실 요즘은 거의 또이또이하다.

C#이 네트워크를 더 잘 지원해준다.


* TCP, UDP 차이

TCP,IP 는 TCP는 IP를 가지고 있기 때문에, 수신자의 주소를 가지고 있다. 즉 아무리 느려져도 결국 수신자에게 도착 할 수 있다.

UDP는 수신자가 안받으면 말짱 도루묵

UDP는 비 연결형 데이터이기 때문에, 로그인같은게 필요 없다.

TCP는 전송 속도가 보장된다. UDP는 전송 속도가 바뀔 수 있다.(즉 UDP는 보낸 시간또한 판단 할 수 있어야 순서대로 받을 수 있다.)

사실 워낙 기본적인 질문이기에 인터넷에 검색해보면 자세하게 나온다.
// UDP는 요즘 거의 안쓴다. 옛날옛적 스타나 워크 Lan 서버가 UDP이다.
// 보안이 없다. 데이터 변조도 얼마든지 가능하고 해서.. 다만 속도는 UDP가 더 빠르다.

*RDBMS
알아서 공부해보셈.
자세하게는 알 필요 없고.

*Unity의 Mono, IL2CPP 차이점.

Unity도 리소스에 관련된 것은 C++을 사용한다.(IL2CPP에서 CPP가 C++임)
리소스는 용량 자체가 크기 때문에 메모리의 크기를 정할 때 가비지콜렉터에 의지하기엔 애매하기 때문에 C++로 처리하는것이다.

일반적인 시스템은 Mono로 구현되어 있고, 리소스에 관련된 부분은 IL2CPP로 구현되어있다고 말하면 됨.

* 더블 버퍼링

전면 버퍼 = 모니터 화면
후면 버퍼 = 컴퓨터 안쪽 화면

컴퓨터는 기본적으로 후면 버퍼에서 처리 한 뒤 처리가 끝나면 전면 버퍼로 스왑한다.
이런 식으로 하면 그리는 과정을 숨김으로써 부드러운 화면전환을 연출 할 수 있는 것이다.


* SVN의 commit, Updata 설명(SVN = Github)
github는 기본적으로 서버에 등록된 저장소와 로컬 저장소로 나뉜다.
파일을 수정 한 뒤 commit을 하면 로컬 저장소와 동기화가 되고. Update를 하면 서버 저장소와 동기화가 된다.
// Update = Push

최적화 경험, 동기 비동기 정의 등등은 본인이 쓰면서 경험한거 대충 말하셈.

